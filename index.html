<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>Luxury Christmas Tree</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #000500;
  overflow: hidden;
  touch-action: none;
}
#root {
  width: 100vw;
  height: 100vh;
}
.rainbow-text {
  position: absolute;
  top: 40px;
  width: 100%;
  text-align: center;
  font-size: 48px;
  font-weight: bold;
  letter-spacing: 6px;
  background: linear-gradient(
    270deg,
    #ff0000,
    #ff7f00,
    #ffff00,
    #00ff00,
    #0000ff,
    #4b0082,
    #9400d3
  );
  background-size: 400% 400%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: rainbow 6s ease infinite;
  pointer-events: none;
  text-shadow: 0 0 25px rgba(255,255,255,0.25);
}
@keyframes rainbow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
</style>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.3.1",
    "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
    "react/jsx-runtime": "https://esm.sh/react@18.3.1/jsx-runtime",
    "react/jsx-dev-runtime": "https://esm.sh/react@18.3.1/jsx-dev-runtime",
    "three": "https://esm.sh/three@0.166.1",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.16.8?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.108.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.2?external=react,react-dom,three,@react-three/fiber"
  }
}
</script>
</head>

<body>
<div id="root"></div>
<div class="rainbow-text">Merry Christmas!</div>

<script type="module">
import React, { useRef, useMemo, useState } from 'react';
import { createRoot } from 'react-dom/client';
import * as THREE from 'three';
import { Canvas, useFrame, extend } from '@react-three/fiber';
import { OrbitControls, Environment, Sparkles, shaderMaterial } from '@react-three/drei';
import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';

/* ---------------- 常量 ---------------- */
const GOLD = new THREE.Color('#FFD700');
const RED  = new THREE.Color('#800020');
const SILVER = new THREE.Color('#C0C0C0');

/* ---------------- Foliage Shader ---------------- */
const FoliageMaterial = shaderMaterial(
{
  uTime: 0,
  uProgress: 0,
  uBase: new THREE.Color('#003311'),
  uTip: new THREE.Color('#006622'),
  uGold: GOLD
},
`
uniform float uTime;
uniform float uProgress;
attribute vec3 aChaosPos;
attribute vec3 aTargetPos;
attribute float aRandom;
attribute float aSize;
varying float vRandom;
varying float vProgress;

void main() {
  vRandom = aRandom;

  float t = smoothstep(
    0.0,
    1.0,
    (uProgress * 1.5) - (1.0 - aRandom) * 0.5
  );
  vProgress = t;

  vec3 pos = mix(aChaosPos, aTargetPos, t);

  float sway = smoothstep(0.8, 1.0, uProgress);
  pos.x += sin(uTime * 2.0 + pos.y) * 0.12 * sway;
  pos.z += cos(uTime * 1.5 + pos.x) * 0.12 * sway;

  vec4 mv = modelViewMatrix * vec4(pos, 1.0);
  gl_PointSize = aSize * (150.0 / -mv.z) * (0.5 + 0.5 * t);
  gl_Position = projectionMatrix * mv;
}
`,
`
uniform vec3 uBase;
uniform vec3 uTip;
uniform vec3 uGold;
varying float vRandom;
varying float vProgress;

void main() {
  vec2 c = gl_PointCoord - 0.5;
  if (length(c) > 0.5) discard;

  float strength = pow(1.0 - length(c) * 2.0, 2.0);
  vec3 col = mix(uBase, uTip, vRandom);
  col = mix(col, uGold, step(0.95, vRandom) * vProgress);
  col += vec3(1.0) * strength * 0.2;

  gl_FragColor = vec4(col, 1.0);
}
`
);
extend({ FoliageMaterial });

/* ---------------- Foliage ---------------- */
function Foliage({ mode }) {
  const mat = useRef();
  const pts = useRef();
  const prog = useRef(0);

  const geo = useMemo(() => {
    const count = 12000;
    const chaos = new Float32Array(count * 3);
    const target = new Float32Array(count * 3);
    const rnd = new Float32Array(count);
    const size = new Float32Array(count);

    const height = 18;
    const baseRadius = 7;

    for (let i = 0; i < count; i++) {
      const r = 15 + Math.random() * 15;
      chaos.set([
        (Math.random() - 0.5) * r,
        (Math.random() - 0.5) * r,
        (Math.random() - 0.5) * r
      ], i * 3);

      const y = Math.random() * height;
      const radiusAtY = baseRadius * (1 - y / height);
      const angle = i * 2.4;
      const dist = Math.sqrt(Math.random()) * radiusAtY;

      target.set([
        Math.cos(angle) * dist,
        y - height / 2,
        Math.sin(angle) * dist
      ], i * 3);

      rnd[i] = Math.random();
      size[i] = Math.random() * 2 + 0.5;
    }

    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.BufferAttribute(chaos, 3));
    g.setAttribute('aChaosPos', new THREE.BufferAttribute(chaos, 3));
    g.setAttribute('aTargetPos', new THREE.BufferAttribute(target, 3));
    g.setAttribute('aRandom', new THREE.BufferAttribute(rnd, 1));
    g.setAttribute('aSize', new THREE.BufferAttribute(size, 1));
    return g;
  }, []);

  useFrame((s, d) => {
    const tgt = mode === 'FORMED' ? 1 : 0;
    prog.current += (tgt - prog.current) * d * 1.2;
    mat.current.uTime = s.clock.elapsedTime;
    mat.current.uProgress = prog.current;
    pts.current.rotation.y += d * 0.05;
  });

  return React.createElement(
    'points',
    { ref: pts, geometry: geo },
    React.createElement('foliageMaterial', {
      ref: mat,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    })
  );
}

/* ---------------- Ornaments ---------------- */
function Ornaments({ mode, count = 250 }) {
  const mesh = useRef();
  const dummy = useMemo(() => new THREE.Object3D(), []);

  const data = useMemo(() => {
    const arr = [];
    const height = 18;
    const baseRadius = 7;

    for (let i = 0; i < count; i++) {
      const y = Math.random() * height - height / 2;
      const normY = (y + height / 2) / height;
      const r = baseRadius * (1 - normY) * 0.9;
      const a = Math.random() * Math.PI * 2;

      arr.push({
        current: new THREE.Vector3(),
        target: new THREE.Vector3(
          Math.cos(a) * r,
          y,
          Math.sin(a) * r
        ),
        chaos: new THREE.Vector3(
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 40
        ),
        speed: Math.random() * 0.5 + 0.5,
        color: Math.random() > 0.6 ? GOLD : Math.random() > 0.5 ? RED : SILVER,
        scale: Math.random() * 0.5 + 0.3
      });
    }
    return arr;
  }, []);

  useFrame((_, d) => {
    data.forEach((o, i) => {
      o.current.lerp(mode === 'FORMED' ? o.target : o.chaos, d * o.speed);

      dummy.position.copy(o.current);

      // ===== ADD：贴着树体的倾斜 =====
      const tilt = (o.target.y + 9) / 18;
      dummy.rotation.x = tilt * 0.8;
      dummy.rotation.z = Math.sin(tilt * Math.PI) * 0.3;
      dummy.rotation.y += d * 0.2;
      // ===== ADD END =====

      dummy.scale.setScalar(o.scale);
      dummy.updateMatrix();

      mesh.current.setMatrixAt(i, dummy.matrix);
      mesh.current.setColorAt(i, o.color);
    });
    mesh.current.instanceMatrix.needsUpdate = true;
    mesh.current.instanceColor.needsUpdate = true;
  });

  return React.createElement(
    'instancedMesh',
    { ref: mesh, args: [null, null, count] },
    React.createElement('sphereGeometry', { args: [1, 16, 16] }),
    React.createElement('meshStandardMaterial', { metalness: 0.9, roughness: 0.1 })
  );
}

/* ---------------- Gift Boxes ---------------- */
function GiftBoxes({ mode, count = 36 }) {
  const mesh = useRef();
  const dummy = useMemo(() => new THREE.Object3D(), []);

  const data = useMemo(() => {
    return Array.from({ length: count }).map(() => {
      const angle = Math.random() * Math.PI * 2;
      const radius = 3.5 + Math.random() * 3;
      return {
        current: new THREE.Vector3(),
        target: new THREE.Vector3(
          Math.cos(angle) * radius,
          -9.8,
          Math.sin(angle) * radius
        ),
        chaos: new THREE.Vector3(
          (Math.random() - 0.5) * 50,
          -25,
          (Math.random() - 0.5) * 50
        ),
        scale: Math.random() * 0.6 + 0.6,
        color: Math.random() > 0.5 ? RED : GOLD
      };
    });
  }, []);

  useFrame((_, d) => {
    data.forEach((o, i) => {
      o.current.lerp(mode === 'FORMED' ? o.target : o.chaos, d * 0.6);
      dummy.position.copy(o.current);
      dummy.rotation.y += d * 0.4;
      dummy.scale.set(o.scale, o.scale * 0.7, o.scale);
      dummy.updateMatrix();
      mesh.current.setMatrixAt(i, dummy.matrix);
      mesh.current.setColorAt(i, o.color);
    });
    mesh.current.instanceMatrix.needsUpdate = true;
    mesh.current.instanceColor.needsUpdate = true;
  });

  return React.createElement(
    'instancedMesh',
    { ref: mesh, args: [null, null, count] },
    React.createElement('boxGeometry', { args: [1, 1, 1] }),
    React.createElement('meshStandardMaterial', { metalness: 0.4, roughness: 0.6 })
  );
}

/* ---------------- Star Topper ---------------- */
/*
function StarTopper({ mode }) {
  const ref = useRef();
  const prog = useRef(0);

  useFrame((_, d) => {
    const tgt = mode === 'FORMED' ? 1 : 0;
    prog.current += (tgt - prog.current) * d * 1.5;

    if (ref.current) {
      ref.current.rotation.y += d * (2 + (1 - prog.current) * 6);
      ref.current.rotation.x += d * 1.2;
      ref.current.position.y = 9.5 + (1 - prog.current) * 6;
    }
  });

  return React.createElement(
    'group',
    { ref, position: [0, 9.5, 0] },
    React.createElement(
      'mesh',
      null,
      React.createElement('octahedronGeometry', { args: [1.5, 0] }),
      React.createElement('meshStandardMaterial', {
        color: GOLD,
        emissive: GOLD,
        emissiveIntensity: 2,
        toneMapped: false
      })
    ),
    React.createElement('pointLight', {
      color: GOLD,
      intensity: 6,
      distance: 12
    })
  );
}
*/
function StarTopper({ mode }) {
  const ref = useRef();
  const prog = useRef(0);

  useFrame((_, d) => {
    const tgt = mode === 'FORMED' ? 1 : 0;
    prog.current += (tgt - prog.current) * d * 1.5;

    if (ref.current) {
      if (mode === 'FORMED') {
        // FORMEEED 状态：纯 y 轴水平旋转，速度加快
        ref.current.rotation.x = 0; // 确保没有 x 轴旋转
        ref.current.rotation.z = 0; // 确保没有 z 轴旋转
        ref.current.rotation.y += d * 6; // 比原来速度快
      } else {
        // 非 FORMEEED 状态：原来的旋转和下降动画
        ref.current.rotation.y += d * (2 + (1 - prog.current) * 6);
        ref.current.rotation.x += d * 1.2;
      }

      // 垂直位置变化
      ref.current.position.y = 9.5 + (1 - prog.current) * 6;
    }
  });

  return React.createElement(
    'group',
    { ref, position: [0, 9.5, 0] },
    React.createElement(
      'mesh',
      null,
      React.createElement('octahedronGeometry', { args: [1.5, 0] }),
      React.createElement('meshStandardMaterial', {
        color: GOLD,
        emissive: GOLD,
        emissiveIntensity: 2,
        toneMapped: false
      })
    ),
    React.createElement('pointLight', {
      color: GOLD,
      intensity: 6,
      distance: 12
    })
  );
}

/* ---------------- Scene ---------------- */
function Scene() {
  const [mode, setMode] = useState('CHAOS');
  const down = useRef(null);

  return React.createElement(
    Canvas,
    {
      camera: { position: [0, 0, 35], fov: 45 },
      onPointerDown: e => down.current = [e.clientX, e.clientY],
      onPointerUp: e => {
        const dx = e.clientX - down.current[0];
        const dy = e.clientY - down.current[1];
        if (Math.sqrt(dx * dx + dy * dy) < 5) {
          setMode(m => m === 'CHAOS' ? 'FORMED' : 'CHAOS');
        }
      }
    },
    React.createElement('color', { attach: 'background', args: ['#000500'] }),
    React.createElement('ambientLight', { intensity: 0.25 }),
    React.createElement(Environment, { preset: 'city' }),
    React.createElement(
      'group',
      { position: [0, -5, 0] },
      React.createElement(Foliage, { mode }),
      React.createElement(Ornaments, { mode }),
      React.createElement(GiftBoxes, { mode }),
      React.createElement(StarTopper, { mode })
    ),
    React.createElement(Sparkles, {
      count: 200,
      scale: 30,
      size: 5,
      speed: 0.4,
      opacity: 0.5,
      color: GOLD
    }),
    React.createElement(
      EffectComposer,
      null,
      React.createElement(Bloom, { intensity: 1.5, radius: 0.6 }),
      React.createElement(Vignette, { darkness: 1.1 }),
      React.createElement(Noise, { opacity: 0.02 })
    ),
    React.createElement(OrbitControls, {
      autoRotate: true,
      autoRotateSpeed: 0.5,
      enablePan: false
    })
  );
}

createRoot(document.getElementById('root'))
  .render(React.createElement(Scene));
</script>
</body>
</html>
